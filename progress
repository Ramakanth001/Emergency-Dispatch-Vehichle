#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#define INF 99999999
int size,source_chosen,destintion_chosen;
int i,j,bookingStatus;
int hosp=22,optimization_path;
char status;
int allDistances[28];
int total_graph[28][28];// Graph for both distance and traffic
int graph[28][28];//graph for distances
int traffic_graph[28][28];// graph for traffic
void dijkstra(int graph[][size], int source) 
{
 int cost[size][size],distance[size];
 int traffic_graph[28][28];
 int visited[size], i, j, cnt, minDistance, nextNode;
 int optimization_path;
 // Initialize cost matrix
 for(i = 0; i < size; i++) 
 {
    for(j = 0; j < size; j++) 
    {
        if(graph[i][j] == 0) 
        {
            cost[i][j] = INF;//If source and node aren't directly connected
        } 
        else 
        {
        cost[i][j] = graph[i][j];//If source and node are directly connected
        }
    }
 }
 // distance of roots directly conneted to source
 for(i = 0; i < size; i++) 
 {
 distance[i] = cost[source][i];// Distance from itself = 0
 visited[i] = 0;// since traversing starts from the source, that node is clearly visited
 }
 distance[source] = 0;// source is the starting point
 visited[source] = 1;
 cnt = 1;
 while(cnt < size - 1) 
 {
    minDistance = INF;
    for(i = 0; i < size; i++) 
    {
        if(distance[i] < minDistance && !visited[i]) //Adjacent and un-visited 
        {
            minDistance = distance[i];
            nextNode = i;
        }
    }
 visited[nextNode] = 1;
 for(i = 0; i < size; i++) //Relaxation function
 {
    if(!visited[i]) 
    {
        if(minDistance + cost[nextNode][i]  < distance[i]) 
        {
            distance[i] = minDistance + cost[nextNode][i] ;
            
        }
    }
 } cnt++;
 }
 for(i = 0; i < size; i++) 
 {
    allDistances[i]=distance[i];
    printf("%d ", allDistances[i]);
 }
}
void costfunction( int units)//Fare estimation function
{
    printf("\nEstimated fare for given distance and fare is %d rupees\n",units*15);
    // Fare per one kilometer is 15 rupees
    
}
void main() {
 size = 28;
int graph[28][28]={ 
     
                        {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,0,0,0},
                        {4,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                        {0,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0},
                        {0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0,0,0,0,0},
                        {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,3,0,0,0,0},
                        {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0},
                        {0,0,0,0,0,2,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5},
                        {0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0},
                        {0,0,0,0,0,0,9,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0},
                        {0,0,0,0,0,0,0,0,0,4,0,0,2,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,5,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,3,0,0,0,0,0,0,0,0,0,0,0,0},
                        {2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,0,0,0,0,0},
                        {3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,4,2,0,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
                        {0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,3},
                        {0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0},
                        {0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,7,0,0,0},
                        {0,0,0,4,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,2,0,1,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0},
                        {0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,2,4,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0}
};

int traffic_graph[28][28]={ 
     

                        {0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0},
                        {2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                        {0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
                        {0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,2,0,0,0,0},
                        {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0},
                        {0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
                        {0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0},
                        {0,0,0,0,0,0,4,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,3,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,0,0},
                        {0,0,0,0,0,0,0,0,0,4,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,4,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0},
                        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0},
                        {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,2,1,0,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
                        {0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2},
                        {0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0},
                        {0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0},
                        {0,0,0,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,3,0,2,0,0,0,0,0,0,0,0,1,0,0,4,0,0,0,0,0},
                        {0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0}


};
for(i = 0; i < size; i++) 
 {
    for(j = 0; j < size; j++) 
    {
        total_graph[i][j]=graph[i][j]+traffic_graph[i][j];
    }
 }
printf("Select source from the following:\n");
printf("****Prime City Locations***\n1.Georgopol\n2.LosSantos\n3.Novo\n4.Lipovka\n5.SanMartin\n6.YasnayaPolana\n7.Severny\n8.Pecado\n9.Gronnus\n10.Blomster\n11.Sosnovka\n12.Pochinki\n13.Miramar\n14.Livik\n15.Sanhok\n16.Rozhok\n17.LosLeones\n18.Gatka\n19.Zharki\n20.NorthYanton\n21.Mylta\n22.Midstein\n");
scanf("%d",& source_chosen);
printf("Select destintion from the following:\n");
printf("\t\t***Hospitals***\n1.Central Los Santos Medical Center\n2.Mount Zonah Medical Center\n3.Sandy Shores Medical Center\n4.The Bay Care Center\n5.Portola Trinity Medical Center\n6.St.Fiacre Medical Center\n\tOR\n\n");
printf("Enter 0 to choose shortest hospital\n");
scanf("%d",&destintion_chosen);
dijkstra(total_graph, source_chosen-1);
int shortestDistance=allDistances[22];
int similar_distances[6];//equal length paths

i=22;
int p=0;//array index of same optimal distance paths
while(i<28)
{
    if(allDistances[i]<shortestDistance)//for equal paths make <=
    {
        //if(allDistances[i]==shortestDistance)
        //{
          //  similar_distances[p]=allDistances[i];
            //p++;
        //}
        //else
    
          shortestDistance=allDistances[i];
          hosp=i;
    }
    i++;
}
char hospitalName[50] = "Central Los Santos Medical Center";
if (destintion_chosen==0)//Nearest hospital 
{
    printf("\nConsidering traffic and distance\nNearest hospital is : ");
    switch(hosp+1)
    {
        case 23 :
            char hospitalName[] = "Central Los Santos Medical Center";
            printf("%s\n",hospitalName);
            break;
        case 24 :
            printf("Mount Zonah Medical Center\n");
            break;
        case 25 :
            printf("Sandy Shores Medical Center\n");
            break;
        case 26 :
            printf("The Bay Care Center\n");
            break;
        case 27 :
            printf("Portola Trinity Medical Center\n");
            break;
        case 28 :
            printf("St.Fiacre Medical Center\n");
            break;
    }
    printf("It is %d kms away\n\n",shortestDistance);
    costfunction(shortestDistance);
 
    
}
else //Manually chosen destintion
 {
    while(destintion_chosen < 7)
    {
        printf("\nIt is %d kms away",allDistances[destintion_chosen+21]);
        //destination gets coverted to node number in city [(1-6) + 21 = (22-27)]
        costfunction(allDistances[destintion_chosen+21]);
        break;
    }
}
printf("Would you like to confirm your ambulance booking?\npress(Y/N)");
scanf("%c",&status);
if(status=='Y' || status=='y')
{
    bookingStatus= 1 ;
}
if(status=='N' || status=='n')
{
    bookingStatus= 0 ;
}
if(bookingStatus)
{
    printf("\n\n***DETAILS REGARDING DISPATCH***\n\n");
    printf("source : ");
}




}


